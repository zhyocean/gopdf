package core

import (
	"fmt"
	"io/ioutil"
	"strconv"
	"strings"

	"github.com/signintech/gopdf"
)

type FontMap struct {
	FontName string
	FileName string
}

// Converter is a bridge to third-party gopdf.
// The content generated by the user by calling a simple interface
// is converted from pdf to complex content, and finally a pdf file
// is generated.
type Converter struct {
	pdf *gopdf.GoPdf

	// Atomic unit, multiple cells are finally combined into a PDF file
	atomicCells []string

	// Basic uint
	// Users can use millimeters, pixels, and inches as the units of pdf files,
	// but ultimately all need to be converted to pixels.
	// The uint here is the conversion unit of millimeters, pixels, and inches
	// to pixels. eg, 1mm = 2.834px
	unit  float64
	fonts []*FontMap // fonts

	linew    float64 // line width
	lastFont string  // last used font name
}

// var convert.unit float64 = 2.834645669

// GetAtomicCells, get atomicCells
func (convert *Converter) GetAutomicCells() []string {
	cells := make([]string, len(convert.atomicCells))
	copy(cells, convert.atomicCells)
	return cells
}

// SetAtomicCells, set atomicCells (use caution)
func (convert *Converter) SetAutomicCells(cells []string) {
	convert.atomicCells = cells
}

// Add a atomicCell to atomicCells
func (convert *Converter) AddAtomicCell(cell string) {
	if strings.HasPrefix(cell, "F|") {
		if cell == convert.lastFont {
			return
		}

		convert.lastFont = cell
	}

	convert.atomicCells = append(convert.atomicCells, cell)
}

// ReadFile parse file content to  atomicCells
// Generate pdf files for text content from already saved atomicCells,
// generally used for debugging.
func (convert *Converter) ReadFile(fileName string) error {
	buf, err := ioutil.ReadFile(fileName)
	if err != nil {
		return err
	}
	text := strings.Replace(string(buf), "\r", "", -1)
	var UTF8_BOM = []byte{239, 187, 191}
	if text[0:3] == string(UTF8_BOM) {
		text = text[3:]
	}
	convert.atomicCells = strings.Split(text, "\n")
	return nil
}

// Generate a pdf file of the content recorded in atomicCells.
func (convert *Converter) Execute() {
	lines := convert.atomicCells
	for _, line := range lines {
		elements := strings.Split(line, "|")
		switch elements[0] {
		case "P":
			convert.Page(line, elements) // pdf start
		case "NP":
			convert.NewPage(line, elements) // new page
		case "F":
			convert.Font(line, elements) // font
		case "TC":
			convert.TextColor(line, elements) // text color
		case "LC":
			convert.LineColor(line, elements) // line color
		case "BC":
			convert.BackgroundColor(line, elements) // backgroup color
		case "GF", "GS":
			convert.Grey(line, elements) //
		case "C", "CL", "CR":
			convert.Cell(line, elements) // cell contens. third lib basic content
		case "L", "LV", "LH", "LT":
			convert.Line(line, elements) // one row
		case "R":
			convert.Rect(line, elements) // rectangle
		case "O":
			convert.Oval(line, elements) // oval
		case "I":
			convert.Image(line, elements) // image
		case "M":
			convert.Margin(line, elements) // margin, can adjust content postion
		case "EL":
			convert.ExternalLink(line, elements) // outer link
		case "ILA":
			convert.InternalLinkAnchor(line, elements) // inner link anchor
		case "ILL":
			convert.InternalLinkLink(line, elements) // inner link linker
		default:
			if len(line) > 0 && line[0:1] != "v" {
				fmt.Println("skip:" + line + ":")
			}
		}
	}
}

// add fonts
func (convert *Converter) AddFont() {
	for _, font := range convert.fonts {
		err := convert.pdf.AddTTFFont(font.FontName, font.FileName)
		if err != nil {
			panic("font file:" + font.FileName + " not found")
		}
	}
}

// Page
// [P, mm|pt|in, A4, P|L]
// mm|pt|in, Indicates the unit of size, respectively representing millimeters, pixels, and feet
// P|L, Page layout, namely Portait, Landscape
func (convert *Converter) Page(line string, elements []string) {
	convert.pdf = new(gopdf.GoPdf)

	checkLength(line, elements, 4)
	switch elements[2] {
	/* A0 ~ A5 Paper pixel representation:
	'A0': [2383.94, 3370.39],
	'A1': [1683.78, 2383.94],
	'A2': [1190.55, 1683.78],
	'A3': [841.89, 1190.55],
	'A4': [595.28, 841.89],
	'A5': [419.53, 595.28],
	*/
	case "A3":
		config := defaultConfigs["A3"]
		convert.setunit(elements[1])
		if elements[3] == "P" {
			convert.start(config.width, config.height)
		} else if elements[3] == "L" {
			convert.start(config.height, config.width)
		} else {
			panic("Page Orientation accept P or L")
		}
	case "A4":
		config := defaultConfigs["A4"]
		convert.setunit(elements[1])
		if elements[3] == "P" {
			convert.start(config.width, config.height)
		} else if elements[3] == "L" {
			convert.start(config.height, config.width)
		} else {
			panic("Page Orientation accept P or L")
		}
	case "LTR":
		config := defaultConfigs["LTR"]
		convert.setunit(elements[1])
		if elements[3] == "P" {
			convert.start(config.width, config.height)
		} else if elements[3] == "L" {
			convert.start(config.height, config.width)
		} else {
			panic("Page Orientation accept P or L")
		}
	default:
		panic("This size not supported yet:" + elements[2])
	}
	convert.AddFont()
	convert.pdf.AddPage()
}

// set uint, uint is "mm", "pt", "in"
func (convert *Converter) setunit(unit string) {
	// 1mm ~ 2.8pt 1in ~ 72pt
	switch unit {
	case "mm":
		convert.unit = 2.834645669
	case "pt":
		convert.unit = 1
	case "in":
		convert.unit = 72
	default:
		panic("This unit is not specified :" + unit)
	}
}

// add new page
func (convert *Converter) NewPage(line string, elements []string) {
	convert.pdf.AddPage()
}

// Set PDF file configuration information (unit, page size)
func (convert *Converter) start(w float64, h float64) {
	convert.pdf.Start(gopdf.Config{
		Unit:     gopdf.Unit_PT,
		PageSize: gopdf.Rect{W: w, H: h},
	}) // 595.28, 841.89 = A4
}

// Set Font used for the current text
// ["", "family", "style", "size"]
// style: "" or "U", ("B", "I")("B" means "Bold", "I" means "Italic", these font self support)
func (convert *Converter) Font(line string, elements []string) {
	checkLength(line, elements, 4)
	err := convert.pdf.SetFont(elements[1], elements[2], parseIntPanic(elements[3], line))
	if err != nil {
		panic(err.Error() + " line;" + line)
	}
}

// Set the gray scale of the stroke Or Set the gray scale of the fill
// ["GF|GS", grayScale]
// grayScale: 0.0 åˆ° 1.0
func (convert *Converter) Grey(line string, elements []string) {
	checkLength(line, elements, 2)
	if elements[0] == "GF" {
		convert.pdf.SetGrayFill(parseFloatPanic(elements[1], line))
	}
	if elements[0] == "GS" {
		convert.pdf.SetGrayStroke(parseFloatPanic(elements[1], line))
	}
}

// text color
// ["", R, G, B]
func (convert *Converter) TextColor(line string, elements []string) {
	checkLength(line, elements, 4)
	convert.pdf.SetTextColor(uint8(parseIntPanic(elements[1], line)),
		uint8(parseIntPanic(elements[2], line)),
		uint8(parseIntPanic(elements[3], line)))
}

// line color
// ["", R, G, B]
func (convert *Converter) LineColor(line string, elements []string) {
	checkLength(line, elements, 4)
	convert.pdf.SetStrokeColor(uint8(parseIntPanic(elements[1], line)),
		uint8(parseIntPanic(elements[2], line)),
		uint8(parseIntPanic(elements[3], line)))
}

// backgroup color
func (convert *Converter) BackgroundColor(line string, elements []string) {
	checkLength(line, elements, 12)

	// white line
	convert.pdf.SetStrokeColor(255, 255, 255)

	// set fill backgroup color
	convert.pdf.SetFillColor(uint8(parseIntPanic(elements[5], line)),
		uint8(parseIntPanic(elements[6], line)),
		uint8(parseIntPanic(elements[7], line)))

	convert.pdf.RectFromUpperLeftWithStyle(parseFloatPanic(elements[1], line)*convert.unit,
		parseFloatPanic(elements[2], line)*convert.unit,
		parseFloatPanic(elements[3], line)*convert.unit,
		parseFloatPanic(elements[4], line)*convert.unit, "F")

	// recover origin backgroup color and line color
	convert.pdf.SetFillColor(1, 1, 1)
	convert.pdf.SetStrokeColor(uint8(parseIntPanic(elements[9], line)),
		uint8(parseIntPanic(elements[10], line)),
		uint8(parseIntPanic(elements[11], line)))

	convert.pdf.SetLineType("solid")
	convert.pdf.SetLineWidth(convert.linew * convert.unit)

	x := parseFloatPanic(elements[1], line) * convert.unit
	y := parseFloatPanic(elements[2], line) * convert.unit
	w := parseFloatPanic(elements[3], line) * convert.unit
	h := parseFloatPanic(elements[4], line) * convert.unit

	// Add lines, contains LEFT, TOP, RIGHT, BOTTOM
	lines := elements[8]
	if lines[0] == '1' {
		convert.pdf.Line(x, y, x, y+h)
	}
	if lines[1] == '1' {
		convert.pdf.Line(x, y, x+w, y)
	}
	if lines[2] == '1' {
		convert.pdf.Line(x+w, y, x+w, y+h)
	}
	if lines[3] == '1' {
		convert.pdf.Line(x, y+h, x+w, y+h)
	}
}

// oval
// ["", x1, y1, x2, y2]
func (convert *Converter) Oval(line string, elements []string) {
	checkLength(line, elements, 5)
	convert.pdf.Oval(parseFloatPanic(elements[1], line)*convert.unit,
		parseFloatPanic(elements[2], line)*convert.unit,
		parseFloatPanic(elements[3], line)*convert.unit,
		parseFloatPanic(elements[4], line)*convert.unit)
}

// rectangle
// ["R", x1, y1, x2, y2]
func (convert *Converter) Rect(line string, eles []string) {
	checkLength(line, eles, 5)
	adj := convert.linew * convert.unit * 0.5
	convert.pdf.Line(
		parseFloatPanic(eles[1], line)*convert.unit,
		parseFloatPanic(eles[2], line)*convert.unit+adj,
		parseFloatPanic(eles[3], line)*convert.unit+adj*2,
		parseFloatPanic(eles[2], line)*convert.unit+adj)

	convert.pdf.Line(
		parseFloatPanic(eles[1], line)*convert.unit+adj,
		parseFloatPanic(eles[2], line)*convert.unit,
		parseFloatPanic(eles[1], line)*convert.unit+adj,
		parseFloatPanic(eles[4], line)*convert.unit+adj*2)

	convert.pdf.Line(
		parseFloatPanic(eles[1], line)*convert.unit,
		parseFloatPanic(eles[4], line)*convert.unit+adj,
		parseFloatPanic(eles[3], line)*convert.unit+adj*2,
		parseFloatPanic(eles[4], line)*convert.unit+adj)

	convert.pdf.Line(
		parseFloatPanic(eles[3], line)*convert.unit+adj,
		parseFloatPanic(eles[2], line)*convert.unit,
		parseFloatPanic(eles[3], line)*convert.unit+adj,
		parseFloatPanic(eles[4], line)*convert.unit+adj*2)
}

// image
// ["I", path, x, y, x1, y2]
func (convert *Converter) Image(line string, elements []string) {
	checkLength(line, elements, 6)
	r := new(gopdf.Rect)
	r.W = parseFloatPanic(elements[4], line)*convert.unit - parseFloatPanic(elements[2], line)*convert.unit
	r.H = parseFloatPanic(elements[5], line)*convert.unit - parseFloatPanic(elements[3], line)*convert.unit

	convert.pdf.Image(
		elements[1],
		parseFloatPanic(elements[2], line)*convert.unit,
		parseFloatPanic(elements[3], line)*convert.unit,
		r,
	)
}

// line
// ["L", x1, y1, x2, y2], Line between any two points
// ["LH", x1, y1, x2], Horizontal line
// ["LV", x1, y2, y2], Vertical line
//
// ["LT", "dashed|dotted|straight", w] Lines with a specific style(dashed,dotted,straight)
// dashed: ----
// dotted: ....
// straight: ___
func (convert *Converter) Line(line string, elements []string) {
	switch elements[0] {
	case "L":
		checkLength(line, elements, 5)
		convert.pdf.Line(
			parseFloatPanic(elements[1], line)*convert.unit,
			parseFloatPanic(elements[2], line)*convert.unit,
			parseFloatPanic(elements[3], line)*convert.unit,
			parseFloatPanic(elements[4], line)*convert.unit,
		)
	case "LH":
		checkLength(line, elements, 4)
		convert.pdf.Line(
			parseFloatPanic(elements[1], line)*convert.unit,
			parseFloatPanic(elements[2], line)*convert.unit,
			parseFloatPanic(elements[3], line)*convert.unit,
			parseFloatPanic(elements[2], line)*convert.unit,
		)
	case "LV":
		checkLength(line, elements, 4)
		convert.pdf.Line(
			parseFloatPanic(elements[1], line)*convert.unit,
			parseFloatPanic(elements[2], line)*convert.unit,
			parseFloatPanic(elements[1], line)*convert.unit,
			parseFloatPanic(elements[3], line)*convert.unit,
		)
	case "LT":
		checkLength(line, elements, 3)
		lineType := elements[1]
		if lineType == "" {
			lineType = "straight"
		}
		convert.pdf.SetLineType(lineType)
		convert.linew = parseFloatPanic(elements[2], line)
		convert.pdf.SetLineWidth(convert.linew * convert.unit)
	}
}

// Clell
// ["C", family, size, x, y, content] // Start writing text from position (x,y)
// ["CL", x, y, content] // Start writing text from position (x,y)
// ["CR", x, y, w, content] // Write text of w length from right to left
func (convert *Converter) Cell(line string, elements []string) {
	switch elements[0] {
	case "C":
		checkLength(line, elements, 6)
		err := convert.pdf.SetFont(elements[1], "", parseIntPanic(elements[2], line))
		if err != nil {
			panic(err.Error() + " line;" + line)
		}
		convert.setPosition(elements[3], elements[4], line)
		convert.pdf.Cell(nil, elements[5])
	case "CL":
		checkLength(line, elements, 4)
		convert.setPosition(elements[1], elements[2], line)
		convert.pdf.Cell(nil, elements[3])
	case "CR":
		checkLength(line, elements, 5)
		tw, err := convert.pdf.MeasureTextWidth(elements[4])
		if err != nil {
			panic(err.Error() + " line;" + line)
		}
		x := parseFloatPanic(elements[1], line) * convert.unit
		y := parseFloatPanic(elements[2], line) * convert.unit
		w := parseFloatPanic(elements[3], line) * convert.unit
		finalx := x + w - tw
		convert.pdf.SetX(finalx)
		convert.pdf.SetY(y)
		convert.pdf.Cell(nil, elements[4])
	}
}

func (convert *Converter) setPosition(x string, y string, line string) {
	convert.pdf.SetX(parseFloatPanic(x, line) * convert.unit)
	convert.pdf.SetY(parseFloatPanic(y, line) * convert.unit)
}

// external link
// ["EL", x, y, w, h, content, link] // Start writing text from (x,y) and add external links
func (convert *Converter) ExternalLink(line string, elements []string) {
	checkLength(line, elements, 7)

	x, y := parseFloatPanic(elements[1], line), parseFloatPanic(elements[2], line)
	w, h := parseFloatPanic(elements[3], line), parseFloatPanic(elements[4], line)

	convert.pdf.SetX(x)
	convert.pdf.SetY(y)

	convert.pdf.Text(elements[5])
	y1 := y
	if y-h > 0 {
		y1 = y - h
	}
	convert.pdf.AddExternalLink(elements[6], x, y1, w, h)

	convert.pdf.SetX(x + w)
	convert.pdf.SetY(y)
}

// Internal link, anchor
// ["ILA", x, y, w, h, content, anchor]
func (convert *Converter) InternalLinkAnchor(line string, elements []string) {
	checkLength(line, elements, 7)

	x, y := parseFloatPanic(elements[1], line), parseFloatPanic(elements[2], line)
	w, h := parseFloatPanic(elements[3], line), parseFloatPanic(elements[4], line)
	convert.pdf.SetX(x)
	convert.pdf.SetY(y)

	convert.pdf.Text(elements[5])
	y1 := y
	if y-h > 0 {
		y1 = y - h
	}
	convert.pdf.AddInternalLink(elements[6], x, y1, w, h)

	convert.pdf.SetX(x + w)
	convert.pdf.SetY(y)
}

// Internal link, link
// ["ILL", x, y, w  content, anchor]
func (convert *Converter) InternalLinkLink(line string, elements []string) {
	checkLength(line, elements, 6)

	convert.pdf.SetX(parseFloatPanic(elements[1], line))
	convert.pdf.SetY(parseFloatPanic(elements[2], line))

	convert.pdf.Text(elements[4])
	convert.pdf.SetAnchor(elements[5])

	convert.pdf.SetX(parseFloatPanic(elements[1], line) + parseFloatPanic(elements[3], line))
	convert.pdf.SetY(parseFloatPanic(elements[2], line))
}

func (convert *Converter) Margin(line string, eles []string) {
	checkLength(line, eles, 3)
	top := parseFloatPanic(eles[1], line)
	left := parseFloatPanic(eles[2], line)
	if top != 0.0 {
		convert.pdf.SetTopMargin(top)
	}

	if left != 0.0 {
		convert.pdf.SetLeftMargin(left)
	}
}

func (convert *Converter) GetXY() (x, y float64) {
	return convert.pdf.GetX(), convert.pdf.GetY()
}

func (convert *Converter) MeasureTextWidth(text string) float64 {
	w, err := convert.pdf.MeasureTextWidth(text)
	if err != nil {
		panic(err)
	}

	return w
}

func (convert *Converter) SetFont(family, style string, size int) {
	convert.pdf.SetFont(family, style, size)
}

func (convert *Converter) NoCompression() {
	convert.pdf.SetNoCompression()
}

func (convert *Converter) WritePdf(filepath string) {
	convert.pdf.WritePdf(filepath)
}

func (convert *Converter) CompressLevel(level int) {
	convert.pdf.SetCompressLevel(level)
}

func (convert *Converter) GetBytesPdf() (ret []byte) {
	return convert.pdf.GetBytesPdf()
}

func checkLength(line string, eles []string, no int) {
	if len(eles) < no {
		panic("Column short:" + line)
	}
}

func parseIntPanic(num string, line string) int {
	i, err := strconv.Atoi(num)
	if err != nil {
		panic(num + " not Integer :" + line)
	}
	return i
}

func parseFloatPanic(num string, line string) float64 {
	if num == "" {
		return 0
	}
	f, err := strconv.ParseFloat(num, 64)
	if err != nil {
		panic(num + " not Numeric :" + line)
	}
	return f
}
